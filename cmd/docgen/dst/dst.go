// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
// Taken from https://github.com/talos-systems/talos/blob/master/hack/docgen/main.go

package main

import (
	"bytes"
	"container/list"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
	"unicode"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"golang.org/x/tools/go/packages"
	yaml "gopkg.in/yaml.v2"
	"mvdan.cc/gofumpt/format"
)

var tpl = `// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
// DO NOT EDIT: this file is automatically generated by docgen
package {{ .Package }}
import (
	"github.com/projectdiscovery/yamldoc-go/encoder"
)
{{ $tick := "` + "`" + `" -}}
var (
	{{ range $struct := .Structs -}}
	{{ $struct.Name }}Doc encoder.Doc
	{{ end -}}
)
func init() {
	{{ range $struct := .Structs -}}
	{{ $docVar := printf "%v%v" $struct.Name "Doc" }}
	{{ $docVar }}.Type = "{{ $struct.Name }}"
	{{ $docVar }}.Comments[encoder.LineComment] = "{{ $struct.Text.Comment }}"
	{{ $docVar }}.Description = "{{ $struct.Text.Description }}"
	{{ range $example := $struct.Text.Examples }}
	{{ if $example.Value }}
	{{ $docVar }}.AddExample("{{ $example.Name }}", {{ $example.Value }})
	{{ end -}}
	{{ end -}}
	{{ if $struct.AppearsIn -}}
	{{ $docVar }}.AppearsIn = []encoder.Appearance{
	{{ range $value := $struct.AppearsIn -}}
		{
			TypeName: "{{ $value.Struct.Name }}",
			FieldName: "{{ $value.FieldName }}",
		},
	{{ end -}}
	}
	{{ end -}}
	{{ $docVar }}.Fields = make([]encoder.Doc,{{ len $struct.Fields }})
	{{ range $index, $field := $struct.Fields -}}
	{{ $docVar }}.Fields[{{ $index }}].Name = "{{ $field.Tag }}"
	{{ $docVar }}.Fields[{{ $index }}].Type = "{{ $field.Type }}"
	{{ $docVar }}.Fields[{{ $index }}].Note = "{{ $field.Note }}"
	{{ $docVar }}.Fields[{{ $index }}].Description = "{{ $field.Text.Description }}"
	{{ $docVar }}.Fields[{{ $index }}].Comments[encoder.LineComment] = "{{ $field.Text.Comment }}"
	{{ range $example := $field.Text.Examples }}
	{{ if $example.Value }}
	{{ $docVar }}.Fields[{{ $index }}].AddExample("{{ $example.Name }}", {{ $example.Value }})
	{{ end -}}
	{{ end -}}
	{{ if $field.Text.Values -}}
	{{ $docVar }}.Fields[{{ $index }}].Values = []string{
	{{ range $value := $field.Text.Values -}}
		"{{ $value }}",
	{{ end -}}
	}
	{{ end -}}
	{{ end -}}
	{{ end }}
}
// Get{{ .Name }}Doc returns documentation for the file {{ .File }}.
func Get{{ .Name }}Doc() *encoder.FileDoc {
	return &encoder.FileDoc{
		Name: "{{ .Name }}",
		Description: "{{ .Header }}",
		Structs: []*encoder.Doc{
			{{ range $struct := .Structs -}}
			&{{ $struct.Name }}Doc,
			{{ end -}}
		},
	}
}
`

type Doc struct {
	Name    string
	Package string
	Title   string
	Header  string
	File    string
	Structs []*Struct
}

type Struct struct {
	Name      string
	Text      *Text
	Fields    []*Field
	AppearsIn []Appearance
}

// GetName returns the name of the struct. If a package name is provided, it
// is returned as well.
func (s *Struct) GetName() string {

}

// GetEscapedName returns the GetName result in escaped form for templating
func (s *Struct) GetEscapedName() string {

}

type Appearance struct {
	Struct    *Struct
	FieldName string
}

type Example struct {
	Name  string `yaml:"name"`
	Value string `yaml:"value"`
}

type Field struct {
	Name    string
	Type    string
	TypeRef string
	Text    *Text
	Tag     string
	Note    string

	embeddedStruct string
}

type Text struct {
	Comment     string     `json:"-"`
	Description string     `json:"description"`
	Examples    []*Example `json:"examples"`
	Values      []string   `json:"values"`
}

func in(p string) (string, error) {
	return filepath.Abs(p)
}

func out(p string) (*os.File, error) {
	abs, err := filepath.Abs(p)
	if err != nil {
		return nil, err
	}

	return os.Create(abs)
}

type structType struct {
	name   string
	text   *Text
	fields []*Field
	node   *dst.StructType
	pkg    *decorator.Package
}

func collectStructsFromPackage(pkg *decorator.Package, structName string) []*structType {
	var structs []*structType

	for _, spec := range pkg.Syntax {
		structs = append(structs, collectStructs(spec, structName, pkg)...)
	}
	return structs
}

func collectStructs(node dst.Node, structName string, pkg *decorator.Package) []*structType {
	structs := []*structType{}

	collectStructs := func(n dst.Node) bool {
		g, ok := n.(*dst.GenDecl)
		if !ok {
			return true
		}

		for _, spec := range g.Specs {
			if parsed := parseStructureFromDSTSpec(n, spec, structName, pkg); parsed != nil {
				structs = append(structs, parsed)
			}
		}
		return true
	}
	dst.Inspect(node, collectStructs)
	return structs
}

func parseStructureFromDSTSpec(node dst.Node, spec dst.Spec, structName string, pkg *decorator.Package) *structType {
	t, ok := spec.(*dst.TypeSpec)
	if !ok {
		return nil
	}

	if t.Type == nil {
		return nil
	}

	x, ok := t.Type.(*dst.StructType)
	if !ok {
		return nil
	}

	gotStructName := t.Name.Name
	if structName != gotStructName {
		return nil
	}

	// Check if we have a package other than root, and add package name as prefix
	// to the struct name.

	if !unicode.IsUpper(rune(structName[0])) {
		return nil
	}

	s := &structType{
		name: gotStructName,
		node: x,
		text: parseComment([]byte(uncommentDecorationNode(node))),
		pkg:  pkg,
	}
	s.fields = collectFields(s)
	return s
}

func parseComment(comment []byte) *Text {
	text := &Text{}
	if err := yaml.Unmarshal(comment, text); err != nil {
		// not yaml, fallback
		text.Description = string(comment)
		// take only the first line from the Description for the comment
		text.Comment = strings.Split(text.Description, "\n")[0]

		// try to parse the everything except for the first line as yaml
		if err = yaml.Unmarshal([]byte(strings.Join(strings.Split(text.Description, "\n")[1:], "\n")), text); err == nil {
			// if parsed, remove it from the description
			text.Description = text.Comment
		}
	} else {
		text.Description = strings.TrimSpace(text.Description)
		// take only the first line from the Description for the comment
		text.Comment = strings.Split(text.Description, "\n")[0]
	}

	text.Description = escape(text.Description)
	for _, example := range text.Examples {
		example.Name = escape(example.Name)
		example.Value = strings.TrimSpace(example.Value)
	}
	return text
}

func getFieldType(p interface{}) string {
	if m, ok := p.(*dst.MapType); ok {
		return getFieldType(m.Value)
	}

	switch t := p.(type) {
	case *dst.Ident:
		return t.Name
	case *dst.ArrayType:
		return getFieldType(p.(*dst.ArrayType).Elt)
	case *dst.StarExpr:
		return getFieldType(t.X)
	case *dst.SelectorExpr:
		return getFieldType(t.Sel)
	default:
		return ""
	}
}

func formatFieldType(p interface{}) string {
	if m, ok := p.(*dst.MapType); ok {
		return fmt.Sprintf("map[%s]%s", formatFieldType(m.Key), formatFieldType(m.Value))
	}

	switch t := p.(type) {
	case *dst.Ident:
		return t.Name
	case *dst.ArrayType:
		return "[]" + formatFieldType(p.(*dst.ArrayType).Elt)
	case *dst.StructType:
		return "struct"
	case *dst.StarExpr:
		return formatFieldType(t.X)
	case *dst.SelectorExpr:
		return formatFieldType(t.Sel)
	case *dst.InterfaceType:
		return "interface{}"
	default:
		log.Printf("unknown: %#v", t)
		return ""
	}
}

var unresolvedStructTracker = newReferenceTracker()

type referenceTracker struct {
	dll     *list.List
	dupeMap map[string]struct{}
}

func newReferenceTracker() *referenceTracker {
	return &referenceTracker{dll: list.New()}
}

func (s *referenceTracker) Push(ref *unresolveStructReference) {
	s.dll.PushBack(ref)
}

func (s *referenceTracker) Pop() *unresolveStructReference {
	if s.dll.Len() == 0 {
		return nil
	}
	tail := s.dll.Back()
	val := tail.Value
	s.dll.Remove(tail)
	return val.(*unresolveStructReference)
}

type unresolveStructReference struct {
	path           string
	structName     string
	finalStructure *structType
	dstPackage     *decorator.Package
}

// addUnresolvedStructToCollection adds an unresolved struct to collection
// The collection is kept deduplicated based on the key parts provided.
func addUnresolvedStructToCollection(ref *unresolveStructReference) {
	unresolvedStructTracker.Push(ref)
}

// resolveUnresolveStructReferences performs resolving of unresolved structures
func resolveUnresolveStructReferences() []*structType {
	var finalStructs []*structType

	for {
		value := unresolvedStructTracker.Pop()
		if value == nil {
			break
		}
		if value.finalStructure != nil {
			finalStructs = append(finalStructs, value.finalStructure)
			continue
		}
		structPackage, ok := value.dstPackage.Imports[value.path]
		if !ok {
			log.Printf("[debug] [ref] no package found for struct %s: %s\n", value.structName, value.path)
			continue
		}
		finalStructs = append(finalStructs, collectStructsFromPackage(structPackage, value.structName)...)
	}
	return finalStructs
}

func collectUnresolvedExternalStructs(p interface{}, pkg *decorator.Package) {
	if m, ok := p.(*dst.MapType); ok {
		collectUnresolvedExternalStructs(m.Key.(dst.Expr), pkg)
		collectUnresolvedExternalStructs(m.Value.(dst.Expr), pkg)
		return
	}

	switch t := p.(type) {
	case *dst.Ident:
		if t.Obj != nil { // in case of arrays of objects
			spec := t.Obj.Decl.(*dst.TypeSpec)
			collectedStruct := parseStructureFromDSTSpec(spec, spec, t.Obj.Name, pkg)
			addUnresolvedStructToCollection(&unresolveStructReference{
				structName:     t.Name,
				dstPackage:     pkg,
				finalStructure: collectedStruct,
			})
		}
		if t.Path != "" {
			addUnresolvedStructToCollection(&unresolveStructReference{
				path:       t.Path,
				structName: t.Name,
				dstPackage: pkg,
			})
		}
	case *dst.ArrayType:
		collectUnresolvedExternalStructs(t.Elt, pkg)
	case *dst.StructType:
		log.Printf("struct: %#v", t)
		//		return "struct"
	case *dst.StarExpr:
		collectUnresolvedExternalStructs(t.X, pkg)
	case *dst.SelectorExpr:
		collectUnresolvedExternalStructs(t.Sel, pkg)
	default:
	}
}

// uncommentDecorationNode uncomments comments for a dst node.
func uncommentDecorationNode(node dst.Node) string {
	decorations := node.Decorations()
	parts := decorations.Start.All()

	commentBuilder := &strings.Builder{}
	for i, part := range parts {
		commentBuilder.WriteString(strings.TrimPrefix(part, "// "))
		if i != len(parts)-1 {
			commentBuilder.WriteString("\n")
		}
	}
	return commentBuilder.String()
}

func escape(value string) string {
	return strings.TrimSpace(strings.ReplaceAll(
		strings.ReplaceAll(value, "\"", "\\\""),
		"\n",
		"\\n",
	))
}

func collectFields(s *structType) (fields []*Field) {
	fields = []*Field{}

	for _, f := range s.node.Fields.List {
		if f.Tag == nil {
			continue
		}
		tag := reflect.StructTag(strings.Trim(f.Tag.Value, "`"))
		yamlTag := tag.Get("yaml")
		yamlTag = strings.Split(yamlTag, ",")[0]

		if yamlTag == "" || yamlTag == "-" {
			continue
		}
		yamlTag = strings.ToLower(yamlTag)

		documentation := uncommentDecorationNode(f)
		if documentation == "" {
			log.Printf("field %q is missing a documentation", f.Names[0].Name)
			continue
		}
		if strings.Contains(documentation, "docgen:nodoc") {
			continue
		}

		if len(f.Names) == 0 {
			//	gotStruct, ok := f.Type.(*dst.Ident)
			//	if !ok {
			//		continue
			//	}

			//		structData := typeSpec.Type.(*dst.StructType)
			//		if !ok {
			//			continue
			//		}
			log.Printf("got embedded struct: %+v\n", f /*structData*/)

			//	embeddedFields := collectFields(&structType{node: structData})
			//			for _, field := range embeddedFields {
			//				fields = append(fields, field)
			//			}
			continue
		}
		name := f.Names[0].Name

		if !unicode.IsUpper(rune(name[0])) {
			continue
		}
		fieldType := formatFieldType(f.Type)
		fieldTypeRef := getFieldType(f.Type)

		collectUnresolvedExternalStructs(f.Type, s.pkg)

		field := &Field{
			Name:    name,
			Tag:     yamlTag,
			Type:    fieldType,
			TypeRef: fieldTypeRef,
			Text:    parseComment([]byte(documentation)),
		}
		fields = append(fields, field)
	}
	return fields
}

func render(doc *Doc, dest string) {
	t := template.Must(template.New("docfile.tpl").Parse(tpl))
	buf := bytes.Buffer{}

	err := t.Execute(&buf, doc)
	if err != nil {
		panic(err)
	}

	formatted, err := format.Source(buf.Bytes(), format.Options{})
	if err != nil {
		log.Printf("data: %s", buf.Bytes())
		panic(err)
	}

	out, err := out(dest)
	defer out.Close()
	_, err = out.Write(formatted)

	if err != nil {
		panic(err)
	}
}

func main() {
	abs, err := in(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}
	structureName := os.Args[3]
	fmt.Printf("creating package file set: %q\n", abs)

	pkgs, err := decorator.Load(&packages.Config{
		Dir:  abs,
		Mode: packages.LoadAllSyntax,
	})
	if err != nil {
		panic(err)
	}

	var structs []*structType
	for _, pkg := range pkgs {
		structs = append(structs, collectStructsFromPackage(pkg, structureName)...)
	}
	if len(structs) == 0 {
		log.Fatalf("failed to find types that could be documented in %s", abs)
	}

	doc := &Doc{
		Package: os.Args[4],
		Name:    structureName,
		Structs: []*Struct{},
	}

	extraExamples := map[string][]*Example{}
	backReferences := map[string][]Appearance{}

	structs = append(structs, resolveUnresolveStructReferences()...)

	for _, s := range structs {
		fmt.Printf("generating docs for type: %q\n", s.name)

		newStruct := &Struct{
			Name:   s.name,
			Text:   s.text,
			Fields: s.fields,
		}

		for _, field := range s.fields {
			if field.TypeRef == "" {
				continue
			}

			if len(field.Text.Examples) > 0 {
				extraExamples[field.TypeRef] = append(extraExamples[field.TypeRef], field.Text.Examples...)
			}

			backReferences[field.TypeRef] = append(backReferences[field.TypeRef], Appearance{
				Struct:    newStruct,
				FieldName: field.Tag,
			})
		}
		doc.Structs = append(doc.Structs, newStruct)
	}

	for _, s := range doc.Structs {
		if extra, ok := extraExamples[s.Name]; ok {
			s.Text.Examples = append(s.Text.Examples, extra...)
		}

		if ref, ok := backReferences[s.Name]; ok {
			s.AppearsIn = append(s.AppearsIn, ref...)
		}
	}

	if len(os.Args) != 5 {
		log.Fatalf("expected 4 args, got %d", len(os.Args)-1)
	}
	doc.File = os.Args[2]
	render(doc, os.Args[2])
}
